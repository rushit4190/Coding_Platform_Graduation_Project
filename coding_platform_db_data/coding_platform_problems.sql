-- MySQL dump 10.13  Distrib 8.0.34, for Win64 (x86_64)
--
-- Host: localhost    Database: coding_platform
-- ------------------------------------------------------
-- Server version	8.0.35

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `problems`
--

DROP TABLE IF EXISTS `problems`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `problems` (
  `problem_id` varchar(255) NOT NULL,
  `all_test_cases` text,
  `custom_test_cases` text,
  `description` text NOT NULL,
  `difficulty` varchar(255) NOT NULL,
  `editorial` text NOT NULL,
  `tags` varchar(255) DEFAULT NULL,
  `title` varchar(255) NOT NULL,
  `expected_output` text,
  `custom_test_output` text,
  PRIMARY KEY (`problem_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problems`
--

LOCK TABLES `problems` WRITE;
/*!40000 ALTER TABLE `problems` DISABLE KEYS */;
INSERT INTO `problems` VALUES ('1','world','Rushit','basic hello world','easy','use standard print statement','not available','First print program','Hello world',NULL),('2',' - world','- Rushit','basic hello - world','easy','use standard print statement','custom','Second print program','hello - world',NULL),('263b6598-1fbe-4e46-80df-9fee1a0e684f','6\n1\n1\n2\n1 1\n3\n1 2 1\n4\n2 3 2 1\n5\n4 5 4 5 4\n10\n1 7 7 2 3 4 3 2 1 100\n',NULL,'You are given an array of integers a1,a2,…,an\n. Calculate the number of subarrays of this array 1≤l≤r≤n\n, such that:\n\nThe array b=[al,al+1,…,ar]\n occurs in the array a\n as a subsequence exactly once. In other words, there is exactly one way to select a set of indices 1≤i1<i2<…<ir−l+1≤n\n, such that bj=aij\n for all 1≤j≤r−l+1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer t\n (1≤t≤104\n) — the number of test cases. This is followed by their description.\n\nThe first line of each test case contains an integer n\n (1≤n≤105\n) — the size of the array a\n.\n\nThe second line of each test case contains n\n integers a1,a2,…,an\n (1≤ai≤109\n).\n\nIt is guaranteed that the sum of n\n over all test cases does not exceed 2⋅105\n.\n\nOutput\nFor each test case, output the number of suitable subarrays. ','hard','Note that a subarray suits us if al\n is the leftmost occurrence of the number al\n in the array and ar\n is the rightmost occurrence of the number ar\n in the array. Let\'s create an array br\n filled with zeros and set br=1\n if ar\n is the rightmost occurrence of the number ar\n in the array (this can be done using sets or dictionaries). Now we need to consider all suitable left boundaries and see how many suitable right boundaries we have on the suffix, either by precomputing a suffix sum or by simply maintaining a variable while traversing from left to right.','codeforces','F. You Are So Beautiful','1\n1\n4\n7\n4\n28',NULL),('3','+ world','+ Rushit','basic hello + world','easy','use standard print statement','custom','Third print program','helo + world',NULL),('4','* world','* world','basic hello * world','easy','use standard print statement','custom','Fourth print program','hello * world',NULL),('573600a6-baaf-40c4-a329-0d7580a11f20','6\n1\n1\n2\n01\n3\n010\n5\n10101\n7\n0000111\n12\n001011000110',NULL,'You are given a number in binary representation consisting of exactly n\n bits, possibly, with leading zeroes. For example, for n=5\n the number 6\n will be given as 00110\n, and for n=4\n the number 9\n will be given as 1001\n.\n\nLet\'s fix some integer i\n such that 1≤i≤n\n. In one operation you can swap any two adjacent bits in the binary representation. Your goal is to find the smallest number of operations you are required to perform to make the number divisible by 2i\n, or say that it is impossible.\n\nPlease note that for each 1≤i≤n\n you are solving the problem independently.\n\nInput\nEach test contains multiple test cases. The first line contains the number of test cases t\n (1≤t≤104\n). The description of the test cases follows.\n\nThe first line of each test case contains one integer n\n (1≤n≤105\n) — the length of the binary representation of the number.\n\nThe second line of each test case contains a string of length n\n, consisting of 0\n and 1\n, — the binary representation of the number.\n\nIt is guaranteed that the sum of n\n over all test cases does not exceed 2⋅105\n.\n\nOutput\nFor each test case, for each 1≤i≤n\n output the smallest number of operations required to make the number divisible by 2i\n, or output −1\n if it is impossible.','easy','import java.io.*;\npublic class App{\n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        \n        //line1 input\n        int t = Integer.parseInt(in.readLine());\n        //line 2 and 3 input\n        for(int T = 1; T <= t; T++){\n            int n = Integer.parseInt(in.readLine());\n            String bin = in.readLine();\n \n            // count number of 0s and store the indexes of 0s from right\n            int cnt = 0;int a = 0;\n            long idx[] = new long[n];\n            for(int i = bin.length()-1; i >= 0; i--){\n                if(bin.charAt(i) == \'0\'){\n                    idx[a++] = i;\n                    cnt++;\n                }\n            }\n            \n            long arr[] = new long[n+1];\n            for(int i = cnt; i<n; i++){\n                arr[i] = -1;\n            }\n \n            long total = 0;\n            for(int i = 1; i <= cnt; i++){\n                total += (bin.length()-i) - idx[i-1];\n                arr[i-1] = total ; \n            }\n \n            for(int i = 0; i < n; i++)\n                System.out.print(arr[i]+\" \");\n            System.out.println();\n        }   \n    }\n}','codeforces','B. Haunted House','-1 \n1 -1 \n0 1 -1 \n1 3 -1 -1 -1 \n3 6 9 12 -1 -1 -1 \n0 2 4 6 10 15 20 -1 -1 -1 -1 -1 \n',NULL),('5b39f36a-9623-423c-9205-2e909f47f702','6\n1 5\n10 8\n37 9\n777 3\n1235 10\n1 10\n',NULL,'A positive integer is called k\n-beautiful, if the digit sum of the decimal representation of this number is divisible by k†\n. For example, 9272\n is 5\n-beautiful, since the digit sum of 9272\n is 9+2+7+2=20\n.\n\nYou are given two integers x\n and k\n. Please find the smallest integer y≥x\n which is k\n-beautiful.\n\n†\n An integer n\n is divisible by k\n if there exists an integer m\n such that n=k⋅m\n.\n\nInput\nEach test contains multiple test cases. The first line contains the number of test cases t\n (1≤t≤104\n). The description of the test cases follows.\n\nThe only line of each test case contains two integers x\n and k\n (1≤x≤109\n, 1≤k≤10\n).\n\nOutput\nFor each test case, output the smallest integer y≥x\n which is k\n-beautiful.','easy','import java.util.Scanner;\n \npublic class Gino {\n \n	public static void main(String[] args) {\n		\n		Scanner scanner = new Scanner(System.in);\n		int testCases = scanner.nextInt();\n		scanner.nextLine();\n		\n		for(int i = 0; i < testCases; i++) {\n			\n			int x = scanner.nextInt();\n			int k = scanner.nextInt();\n			scanner.nextLine();\n			\n			int somma;\n			int y;\n			\n			do {\n				somma = 0;\n				y = x;\n				\n				do {\n					somma += y % 10;\n					y/= 10;\n				}while(y > 0);\n			\n				x++;\n			} while(somma % k != 0);\n			x--;\n			System.out.println(x);\n		}\n \n	}\n \n}','codeforces','A. Simple Design','5\n17\n45\n777\n1243\n19',NULL),('99cb8a25-00e9-4a3c-b829-40b5c2c655be','6\n4\n2 4 4 4\n4\n2 3 4 4\n9\n6 8 9 4 6 8 9 4 9\n9\n7 7 4 4 9 9 6 2 9\n18\n10 18 18 15 14 4 5 6 8 9 10 12 15 16 18 17 13 11\n21\n12 19 19 18 18 12 2 18 19 12 12 3 12 12 12 18 19 16 18 19 12\n',NULL,'You are given an array of integers a1,a2,…,an\n.\n\nA pair of integers (i,j)\n, such that 1≤i<j≤n\n, is called good, if there does not exist an integer k\n (1≤k≤n\n) such that ai\n is divisible by ak\n and aj\n is divisible by ak\n at the same time.\n\nPlease, find the number of good pairs.\n\nInput\nEach test contains multiple test cases. The first line contains the number of test cases t\n (1≤t≤2⋅104\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer n\n (1≤n≤106\n).\n\nThe second line of each test case contains n\n integers a1,a2,…,an\n (1≤ai≤n\n).\n\nIt is guaranteed that the sum of n\n over all test cases does not exceed 106\n.\n\nOutput\nFor each test case, output the number of good pairs.','medium','import java.io.*;\nimport java.util.StringTokenizer;\n \npublic class Main {\n \n    public static void solve() throws IOException{\n        int n = in.nextInt();\n        int[] cnt = new int[n+1];\n        boolean[] isHave = new boolean[n+1];\n        for (int i = 0, a; i < n; i++) {\n            a = in.nextInt();\n            cnt[a]++;\n            isHave[a] = true;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + i; j <= n; j += i) {\n                if (isHave[i]) isHave[j] = true;\n                cnt[i] += cnt[j];\n            }\n        }\n        long[] dp = new long[n+1];\n        for (int i = n; i >= 1; i--) {\n            dp[i] = (long) cnt[i] * (cnt[i] - 1) / 2;\n            for (int j = i + i; j <= n; j += i) {\n                dp[i] -= dp[j];\n            }\n        }\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!isHave[i]) ans += dp[i];\n        }\n        out.println(ans);\n    }\n \n    static boolean MULTI_CASE = true;\n \n    public static void main(String[] args) throws IOException {\n        if (MULTI_CASE) {\n            int T = in.nextInt();\n            for (int i = 0; i < T; ++i) {\n                solve();\n            }\n        } else {\n            solve();\n        }\n        out.close();\n    }\n \n    static InputReader in = new InputReader();\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n \n    static class InputReader {\n        private StringTokenizer st;\n        private BufferedReader bf;\n \n        public InputReader() {\n            bf = new BufferedReader(new InputStreamReader(System.in));\n            st = null;\n        }\n \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(bf.readLine());\n            }\n            return st.nextToken();\n        }\n \n        public String nextLine() throws IOException {\n            return bf.readLine();\n        }\n \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n}\n \n/*\n \n */','codeforces','D. Counting Rhyme','0\n3\n26\n26\n124\n82\n',NULL),('b0651c66-34dc-443f-808e-71d7929dedce','14\n1 0\na\n2 0\nab\n2 1\nba\n3 1\nabb\n3 2\nabc\n6 2\nbacacd\n6 2\nfagbza\n6 2\nzwaafa\n7 2\ntaagaak\n14 3\nttrraakkttoorr\n5 3\ndebdb\n5 4\necadc\n5 3\ndebca\n5 3\nabaac\n',NULL,'You are given a string s\n of length n\n, consisting of lowercase Latin letters, and an integer k\n.\n\nYou need to check if it is possible to remove exactly k\n characters from the string s\n in such a way that the remaining characters can be rearranged to form a palindrome. Note that you can reorder the remaining characters in any way.\n\nA palindrome is a string that reads the same forwards and backwards. For example, the strings \"z\", \"aaa\", \"aba\", \"abccba\" are palindromes, while the strings \"codeforces\", \"reality\", \"ab\" are not.\n\nInput\nEach test consists of multiple test cases. The first line contains a single integer t\n (1≤t≤104\n) — the number of the test cases. This is followed by their description.\n\nThe first line of each test case contains two integers n\n and k\n (0≤k<n≤105\n) — the length of the string s\n and the number of characters to be deleted.\n\nThe second line of each test case contains a string s\n of length n\n, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of n\n over all test cases does not exceed 2⋅105\n.\n\nOutput\nFor each test case, output \"YES\" if it is possible to remove exactly k\n characters from the string s\n in such a way that the remaining characters can be rearranged to form a palindrome, and \"NO\" otherwise.\n\nYou can output the answer in any case (uppercase or lowercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive answers. ','easy','Not Available','codeforces','B. Chemistry','YES\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n',NULL),('b171dac1-b9ab-424a-9529-89a350d76716','5\n1\n3\n6\n179\n1000000000000000000\n',NULL,'Tema decided to improve his ice cream making skills. He has already learned how to make ice cream in a cone using exactly two balls.\n\nBefore his ice cream obsession, Tema was interested in mathematics. Therefore, he is curious about the minimum number of balls he needs to have in order to make exactly n\n different types of ice cream.\n\nThere are plenty possible ice cream flavours: 1,2,3,…\n. Tema can make two-balls ice cream with any flavours (probably the same).\n\nTwo ice creams are considered different if their sets of ball flavours are different. For example, {1,2}={2,1}\n, but {1,1}≠{1,2}\n.\n\nFor example, having the following ice cream balls: {1,1,2}\n, Tema can make only two types of ice cream: {1,1}\n and {1,2}\n.\n\nNote, that Tema do not need to make all the ice cream cones at the same time. This means that he making ice cream cones independently. Also in order to make a following cone {x,x}\n for some x\n, Tema needs at least 2\n balls of type x\n.\n\nHelp Tema answer this question. It can be shown that answer always exist.\n\nInput\nEach test consists of multiple test cases. The first line of input contains a single integer t\n (1≤t≤104\n) — the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains a single integer n\n (1≤n≤1018\n) — the number of ice cream types that Tema wants to make.\n\nOutput\nFor each test case, output a single integer — the minimum number of balls Tema needs to buy.','medium','import java.io.*;\nimport java.util.StringTokenizer;\n \npublic class Main {\n \n \n    /*\n     m * (m + 1) / 2 <= target <= m * (m + 1) / 2 + m\n                        target <= x * (x + 1) / 2\n     */\n \n    public void solve() throws IOException {\n        long n = in.nextLong();\n        long l = 2, r = Long.parseLong(\"2648956421\");\n        long pos = 0;\n        while (l <= r) {\n            long mid = (r - l >> 1) + l; //多少种\n            long tmp = mid * (mid - 1) / 2;\n            if (tmp > n)  r = mid - 1;\n            else {\n                pos = mid;\n                l = mid + 1;\n            }\n        }\n        long ans = pos + n - pos * (pos - 1) / 2;\n \n        out.println(ans);\n    }\n \n \n    boolean MULTI_CASE = true;\n \n    public void goToSolve() throws IOException {\n        if (MULTI_CASE) {\n            int T = in.nextInt();\n            for (int i = 0; i < T; ++i) {\n                solve();\n            }\n        } else {\n            solve();\n        }\n        out.close();\n    }\n \n    public static void main(String[] args) throws IOException {\n        new Pro_1862D().goToSolve();\n    }\n \n    static InputReader in = new InputReader();\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n \n    static class InputReader {\n        private StringTokenizer st;\n        private BufferedReader bf;\n \n        public InputReader() {\n            bf = new BufferedReader(new InputStreamReader(System.in));\n            st = null;\n        }\n \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(bf.readLine());\n            }\n            return st.nextToken();\n        }\n \n        public String nextLine() throws IOException {\n            return bf.readLine();\n        }\n \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n}\n \n','codeforces','D. Ice Cream Balls','2\n3\n4\n27\n2648956421\n',NULL),('f0cf4010-023f-4abe-865c-26daacf81729','5 2\n4\n1 2\n2 3\n3 4\n4 5\n2\n2 3\n3 5\n6\n2 1 2 1 2 1\n',NULL,'Berland is a country with ancient history, where roads were built and destroyed for centuries. It is known that there always were n\n cities in Berland. You also have records of t\n key moments in the history of the country, numbered from 1\n to t\n. Each record contains a list of bidirectional roads between some pairs of cities, which could be used for travel in Berland at a specific moment in time.\n\nYou have discovered a time machine that transports you between key moments. Unfortunately, you cannot choose what point in time to end up at, but you know the order consisting of k\n moments in time ai\n, in which the machine will transport you. Since there is little time between the travels, when you find yourself in the next key moment in time (including after the last time travel), you can travel on at most one existing road at that moment, coming out from the city you were in before time travel.\n\nCurrently, you are in city 1\n, and the time machine has already transported you to moment a1\n. You want to reach city n\n as quickly as possible. Determine the minimum number of time travels, including the first one, that you need to make in order to reach city n\n.\n\nInput\nThe first line contains two integers n\n and t\n (2≤n≤2⋅105,1≤t≤2⋅105\n) — the number of cities in Berland and the number of records about key moments in history. Then follows the description of each of the t\n records.\n\nThe first line of each record description contains a single integer mi\n (0≤mi≤min(n(n−1)2,2⋅105)\n) — the number of roads in the i\n-th record.\n\nEach of the next mi\n lines contains two integers vj\n and uj\n (1≤vj,uj≤n\n, vj≠uj\n) — the numbers of cities connected by the j\n-th road in the i\n-th key moment in history.\n\nThe next line contains a single integer k\n (1≤k≤2⋅105\n) — the number of time moments between which movements will occur.\n\nThe next line contains k\n integers a1,a2,…,ak\n (1≤ai≤t\n) — the time moments at which you will be after each movement.\n\nIt is guaranteed that the sum of mi\n does not exceed 2⋅105\n. It is guaranteed that each unordered pair (u,v)\n occurs in the road description for one record no more than once.\n\nOutput\nOutput a single integer — the minimum number of time travels required to reach city n\n from city 1\n, or −1\n if it is impossible.\n\nNote that movement to time moment a1\n is also considered a movement.','easy','Not Available','codeforces','Time Travel','5\n',NULL),('f8853914-8cac-4975-b198-780eed531dfa','3\n4\n1 7 6 5\n5\n1 2 3 4 5\n2\n0 -4\n',NULL,'You have an array a\n of length n\n. For every positive integer x\n you are going to perform the following operation during the x\n-th second:\n\nSelect some distinct indices i1,i2,…,ik\n which are between 1\n and n\n inclusive, and add 2x−1\n to each corresponding position of a\n. Formally, aij:=aij+2x−1\n for j=1,2,…,k\n. Note that you are allowed to not select any indices at all.\nYou have to make a\n nondecreasing as fast as possible. Find the smallest number T\n such that you can make the array nondecreasing after at most T\n seconds.\n\nArray a\n is nondecreasing if and only if a1≤a2≤…≤an\n.\n\nYou have to answer t\n independent test cases.\n\nInput\nThe first line contains a single integer t\n (1≤t≤104\n) — the number of test cases.\n\nThe first line of each test case contains single integer n\n (1≤n≤105\n) — the length of array a\n. It is guaranteed that the sum of values of n\n over all test cases in the input does not exceed 105\n.\n\nThe second line of each test case contains n\n integers a1,a2,…,an\n (−109≤ai≤109\n).\n\nOutput\nFor each test case, print the minimum number of seconds in which you can make a\n nondecreasing.','easy','import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = Integer.parseInt(br.readLine());\n        while(t-- > 0){\n            int n = Integer.parseInt(br.readLine());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++){\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n            int maxseconds = 0;\n            for(int i = 1; i < n; i++){\n                int prev = arr[i-1];\n                int curr = arr[i];\n                int diff = -1;\n                if(prev > curr){\n                    diff = prev - curr;\n                    maxseconds = Math.max(maxseconds,log2(diff)+1);\n                    arr[i] += diff;\n                }\n \n            }\n            pw.println(maxseconds);\n        }\n        pw.close();\n    }\n    static int log2(int x){\n        return (int)Math.floor((Math.log(x)/Math.log(2)));\n    }\n}\n','codeforces','A. Powered Addition','2\n0\n3\n',NULL);
/*!40000 ALTER TABLE `problems` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-10-28 23:22:31
